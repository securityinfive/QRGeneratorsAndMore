<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Gyroscope Orb â€¢ Particles</title>
  <style>
    html, body { height: 100%; margin: 0; }
    body { background:#000; overflow:hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #stage { position:fixed; inset:0; width:100vw; height:100vh; display:block; }
    .hint { position:fixed; left:14px; bottom:12px; color:rgba(255,255,255,.65); font-size:12px; user-select:none; pointer-events:none; }
  </style>
</head>
<body>
  <canvas id="stage"></canvas>
  <div class="hint">Multicolored orb with three rotating particle rings</div>

<script>
(function(){
  const canvas = document.getElementById('stage');
  const ctx = canvas.getContext('2d', { alpha:false });

  let W=0,H=0, dpr=Math.max(1, window.devicePixelRatio||1);
  function resize(){
    W = window.innerWidth; H = window.innerHeight;
    canvas.width = Math.floor(W*dpr);
    canvas.height = Math.floor(H*dpr);
    canvas.style.width = W+'px';
    canvas.style.height = H+'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
    // solid black once
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,W,H);
  }
  window.addEventListener('resize', resize);
  resize();

  // Scene setup
  const cx = () => W*0.5;
  const cy = () => H*0.5;
  const baseRadius = Math.min(W,H)*0.12; // orb radius
  const ringRadius = Math.min(W,H)*0.28; // ring radius

  // Camera / perspective
  const fov = 700; // larger = less perspective

  function rotate3D(p, ax, ay, az){
    // Rotations in X, Y, Z order
    let {x,y,z} = p;
    // X
    let cos = Math.cos(ax), sin = Math.sin(ax);
    let y1 = y*cos - z*sin; let z1 = y*sin + z*cos; y=y1; z=z1;
    // Y
    cos = Math.cos(ay); sin = Math.sin(ay);
    let x2 = x*cos + z*sin; let z2 = -x*sin + z*cos; x=x2; z=z2;
    // Z
    cos = Math.cos(az); sin = Math.sin(az);
    let x3 = x*cos - y*sin; let y3 = x*sin + y*cos; x=x3; y=y3;
    return {x,y,z};
  }

  function project(p){
    // simple perspective projection
    const scale = fov / (fov - p.z);
    return { x: cx() + p.x*scale, y: cy() + p.y*scale, s: scale };
  }

  // Ring definitions (tilts and spin speeds)
  const rings = [
    { tiltX: 0.95, tiltY: 0.25, spin:  0.45, hueOffset:   0 },
    { tiltX: 0.15, tiltY: 1.10, spin: -0.32, hueOffset: 120 },
    { tiltX: 0.70, tiltY:-0.55, spin:  0.25, hueOffset: 240 },
  ];

  // Particle parameters per ring
  const pointsPerRing = 220; // density of particles
  const ringThickness = 0.6; // visual thickness multiplier

  // Time
  let last = performance.now();

  function drawOrb(time){
    const r = baseRadius;
    const g = ctx.createRadialGradient(cx()-r*0.25, cy()-r*0.25, r*0.2, cx(), cy(), r);
    // Cycle through hues over time
    const hue = (time*0.03)%360;
    g.addColorStop(0, `hsla(${(hue+40)%360},100%,65%,1)`);
    g.addColorStop(0.45, `hsla(${(hue+160)%360},95%,55%,0.95)`);
    g.addColorStop(0.8, `hsla(${(hue+280)%360},85%,40%,0.85)`);
    g.addColorStop(1, 'rgba(0,0,0,0.0)');

    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.filter = 'blur(0px)';
    ctx.beginPath();
    ctx.fillStyle = g;
    ctx.arc(cx(), cy(), r, 0, Math.PI*2);
    ctx.fill();

    // soft halo
    ctx.globalAlpha = 0.25;
    ctx.filter = 'blur(18px)';
    ctx.beginPath();
    ctx.fillStyle = `hsla(${(hue+200)%360}, 85%, 55%, 0.9)`;
    ctx.arc(cx(), cy(), r*1.35, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function drawRing(time, cfg){
    const { tiltX, tiltY, spin, hueOffset } = cfg;
    const t = time * spin * 0.0015; // rotation over time

    // Render particles around the circle
    // We draw farther points first based on z for better overlap
    const pts = [];
    for(let i=0;i<pointsPerRing;i++){
      // Parameter along circle, include a small drift to make the particles flow
      const u = (i/pointsPerRing + time*0.00025) % 1;
      const theta = u * Math.PI*2;
      const r = ringRadius;
      const base = { x: Math.cos(theta)*r, y: Math.sin(theta)*r*ringThickness, z: 0 };
      const rot = rotate3D(base, tiltX + t, tiltY + t*0.6, 0);
      const P = project(rot);
      pts.push({ P, z: rot.z, u });
    }
    pts.sort((a,b)=>a.z-b.z); // draw back to front

    for(const pt of pts){
      const { P, u } = pt;
      // Color varies by arc position and ring offset
      const hue = (hueOffset + u*360 + time*0.03)%360;
      const alpha = 0.75 * Math.min(1, Math.max(0.15, P.s));
      const size = 1.0 + 2.0 * P.s; // perspective size

      ctx.beginPath();
      ctx.fillStyle = `hsla(${hue}, 90%, 60%, ${alpha})`;
      ctx.arc(P.x, P.y, size, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function frame(now){
    const dt = Math.min(0.033, (now-last)/1000);
    last = now;

    // motion fade for silky trails
    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle = 'rgba(0,0,0,0.10)'; // lower alpha = longer trails
    ctx.fillRect(0,0,W,H);

    // central orb
    drawOrb(now);

    // rings
    ctx.globalCompositeOperation = 'lighter';
    ctx.shadowBlur = 8; ctx.shadowColor = 'rgba(255,255,255,0.35)';
    for(const r of rings){
      drawRing(now, r);
    }
    ctx.shadowBlur = 0; ctx.shadowColor = 'transparent';

    requestAnimationFrame(frame);
  }

  last = performance.now();
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
